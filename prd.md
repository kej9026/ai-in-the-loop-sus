# [PRD] Niche Universe Archive (NUA)
- 지능형 통합 미디어 큐레이션 및 기록 플랫폼 -
## 1. 서비스 개요 (Service Overview)
•	디자인 톤: "보라색 포인트의 세련된 다크 모드"
o	매니아틱한 장르(스릴러, 누아르 등)와 잘 어울리는 깊은 그레이/블랙 배경에 네온 퍼플을 강조색으로 사용하여 세련된 아카이브 느낌을 전달합니다.
•	핵심 가치: "파편화된 기록의 통합과 소비 과정의 시각화"
o	단순히 '무엇을 봤다'는 결과뿐만 아니라, **'언제부터 언제까지 소비했는가'**라는 과정을 달력 기반의 기간 바(Period Bar)로 시각화하여 나만의 미디어 유니버스를 구축합니다.
💡 시니어 개발자의 팁
디자인 톤에서 다크 모드를 선택할 때는 단순히 검은색(#000000)을 쓰는 게 아니라, 텍스트 가독성을 위해 아주 어두운 무채색(#121212)을 베이스로 까는 게 실력이야. 보라색 포인트는 사용자 액션 버튼(CTA)에만 집중적으로 배치해서 시선을 유도해보게.
________________________________________
## 2. 기능 명세 (Key Features)
### 2.1 정렬 및 필터 로직 (Backend Logic)
•	우선순위: 메인 화면의 '최근 활동' 리스트는 **updated_at (최근 수정순)**을 1순위로 노출합니다.
•	정렬 조건:
o	ORDER BY updated_at DESC: 현재 기록 중이거나 방금 기록을 마친 아이템이 상단에 노출되도록 설계.
o	달력 정렬: start_date 기준 오름차순으로 배치하여 타임라인의 흐름을 유지.
2.2 UI 컴포넌트 (v0.dev 기반)
•	미디어 카드: 이미지(Poster), 타이틀, AI 추출 태그(Badge), 매체 아이콘(Icon) 포함.
•	통합 검색창: 영화/게임/도서 탭 구분 및 실시간 API 검색 결과 리스트업.
•	기록 폼(Form): 별점(Star Rating), 날짜 선택기(Date Range Picker), 커스텀 태그 입력 필드.
2.3 데이터 검증 (Validation)
•	필수 항목: title, media_type, external_id, start_date.
•	유효성 검사:
o	end_date는 반드시 start_date보다 미래여야 함.
o	media_type은 ['movie', 'game', 'book'] 중 하나여야 함.
💡 시니어 개발자의 팁
ORDER BY 쿼리를 짤 때 데이터량이 많아지면 인덱스(Index) 성능이 중요해져. updated_at 컬럼에 인덱스를 걸어두는 걸 잊지 말게. 그리고 날짜 유효성 검사는 클라이언트(Next.js)뿐만 아니라 DB(Supabase) 단에서도 CHECK constraint를 걸어주는 게 데이터 무결성에 좋다네.
________________________________________
3. 유저 플로우 (User Flow)
1.	비회원 탐색: 서비스 소개 랜딩 페이지와 공개 대시보드 샘플 조회.
2.	로그인 (MVP): Supabase Auth(Google/Github)를 통한 본인 인증 및 개인 저장소 생성.
3.	작품 검색 및 추가: 통합 검색 모달을 통해 작품 선택 -> 'Prefix ID' 자동 생성 및 기록 시작.
4.	기록 및 AI 분석: 상태 설정(진행 중/완료) -> Gemini가 줄거리 분석 후 자동 태깅 및 요약 생성.
5.	상세 조회: 내 달력에서 기간 바 확인 및 AI가 분석한 나의 전체 취향 페르소나 리포트 확인.
________________________________________
4. 데이터 모델링 (DBA 관점)
[Main Table: media_items]
UI 요소와 정렬 로직을 처리하기 위한 핵심 스키마입니다.
컬럼명	데이터 타입	설명
id	TEXT	PK. m_, g_, b_ 접두사 + 외부 ID 조합.
user_id	UUID	FK. auth.users(id) 참조.
media_type	TEXT	매체 구분 (movie, game, book).
status	TEXT	진행 상태 (wishlist, in_progress, completed).
start_date	DATE	기록 시작일 (달력 기간 바의 시작점).
end_date	DATE	기록 완료일 (달력 기간 바의 끝점).
updated_at	TIMESTAMPTZ	정렬용. 최근 수정 시간.
ai_metadata	JSONB	Gemini가 추출한 분위기, 테마 태그 저장.
💡 시니어 개발자의 팁
media_type마다 다른 상세 정보(예: 영화의 감독, 게임의 개발사)를 담아야 할 수도 있어. 그럴 땐 매번 테이블을 쪼개기보다 media_details라는 테이블을 따로 만들고 id를 1:1 관계로 연결하는 게 관리하기 훨씬 편할 거야.
________________________________________
5. 예외 처리 (Edge Cases)
•	검색 결과 없음: "찾으시는 작품이 없나요? 직접 등록하거나 AI에게 비슷한 작품을 추천받아보세요." 문구와 함께 추천 서비스 연결.
•	외부 API 호출 실패: API 서버 일시적 장애 시, DB에 이미 캐싱된 데이터를 보여주거나 "나중에 다시 시도해주세요" 안내.
•	잘못된 접근: 로그인하지 않은 유저가 기록 페이지 접근 시 로그인 페이지로 리다이렉트 및 안내 메시지 출력.
🚀 NUA (Niche Universe Archive) 프로젝트 구분 PRD
1. Phase 1: MVP (3일 내 구현 목표)
핵심 가치: 파편화된 기록의 '단일화된 저장'과 'AI 자동 분석' 루프 완성
구분	상세 명세	기술 스택
인증 (Auth)	Google Social Login만 우선 구현 (가장 빠름)	Supabase Auth
데이터 (CRUD)	텍스트 기반 직접 입력: 제목, 매체 타입(영화/게임/도서), 진행 상태, 시작/종료일	Next.js, Supabase
AI 기능	텍스트 기반 태깅: 저장 시 제목을 바탕으로 Gemini가 무드 태그(3개) 및 한 줄 평 생성	Gemini 1.5 Flash
UI/UX	표준 대시보드: v0.dev로 생성한 다크 모드 레이아웃 + 기본적인 기록 리스트	shadcn/ui, Tailwind
데이터 모델	media_items 테이블 기본 컬럼 (id, user_id, title, type, status, dates, tags)	PostgreSQL
________________________________________
2. Phase 2: 고도화 (수업 이후 진행)
핵심 가치: 데이터 시각화의 정교화 및 사용자 편의성 극대화
•	데이터 연동 (External APIs)
o	TMDB(영화), RAWG(게임), Google Books API 연동을 통한 자동 검색 및 데이터 채우기.
o	Prefix ID(m_, g_, b_) 자동 부여 시스템 구축.
•	고급 시각화 (Visualization)
o	Recharts 도입: 장르별 분포 도넛 차트 및 월별 활동량 통계 대시보드.
o	Period Bar UI: 달력에서 시작일부터 종료일까지 가로로 이어지는 기간 바 형태 구현.
•	기능 확장
o	이미지/포스터 업로드 및 관리 (Supabase Storage).
o	사용자 간 기록 공유 및 실시간 댓글/채팅 기능.
o	복잡한 필터링 알고리즘 (장르별, 평점별, 기간별 정렬).
•	인터랙션
o	드래그 앤 드롭을 이용한 달력 날짜 수정.
o	애니메이션 효과를 가미한 전문적인 UI 인터랙션.
________________________________________
🏗️ NUA (Niche Universe Archive) 기능 중심 개발 일정
Day 1: 인증 인프라 및 데이터 스키마 구축
핵심 목표: 사용자가 로그인하고 본인의 데이터를 안전하게 저장할 공간을 만드는 것 
•	프로젝트 초기화: Next.js(App Router) 환경 설정 및 Supabase 연동.
•	인증 환경 설정: Supabase Auth를 활용한 Google Social Login 연동.
•	DB 스키마 적용: media_items 테이블을 생성하고 RLS(Row Level Security) 정책을 설정하여 본인의 데이터만 접근 가능하도록 처리.
•	기본 API Route 생성: 데이터 추가(C) 및 목록 불러오기(R)를 위한 서버 액션(Server Actions) 또는 API 엔드포인트 작성.
________________________________________
Day 2: AI 연동 및 비즈니스 로직 최적화
핵심 목표: 입력된 텍스트를 AI가 분석하고 상황에 맞는 데이터를 자동 생성하는 것 
•	Gemini API 연동: 사용자가 입력한 제목을 기반으로 'Mood' 태그와 '한 줄 평'을 생성하는 프롬프트 엔지니어링 및 연동 로직 구현.
•	데이터 자동화 로직: 상태가 completed로 변경될 때 end_date를 현재 시간으로 자동 업데이트하는 기능 구현.
•	태그 저장 로직: AI가 생성한 JSON 형태의 태그 데이터를 DB의 tags(JSONB) 컬럼에 파싱하여 저장하는 기능 구현.
•	예외 처리: AI 응답 실패 시 기본 태그를 할당하거나 빈 값을 허용하는 폴백(Fallback) 로직 구축.
________________________________________
Day 3: 데이터 필터링 및 최종 통합 테스트
핵심 목표: 저장된 데이터를 정교하게 정렬하고 안정적으로 배포하는 것 
•	정렬 및 필터 로직: 최신순, 상태별(위시리스트/진행중/완료) 필터링 및 매체 타입별(영화/게임/도서) 분류 로직 구현.
•	데이터 정규화 검증: 각 데이터가 지정된 Enum 타입과 날짜 형식에 맞게 저장되는지 최종 검증.
•	통합 테스트: 로그인 -> 기록 작성 -> AI 태깅 -> 리스트 확인 -> 삭제로 이어지는 전체 사용자 시나리오 테스트.
•	Vercel 배포: 환경 변수(API Key 등)를 설정하고 최종 서비스 배포.
	
